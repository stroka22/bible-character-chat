#!/usr/bin/env node

/**
 * debug_chat_system.js
 * 
 * This script tests the mock response system independently of the React app.
 * It verifies that mock responses can be generated and streamed correctly.
 * 
 * Usage: node debug_chat_system.js
 */

import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';

// ANSI color codes for prettier output
const COLORS = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  bgRed: '\x1b[41m',
  bgGreen: '\x1b[42m'
};

// Get the directory name using ES modules approach
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Dynamically import the mockResponseService
async function runTests() {
  console.log(`${COLORS.bright}${COLORS.blue}=== BIBLE CHARACTER CHAT - MOCK RESPONSE SYSTEM DEBUG ===\n${COLORS.reset}`);
  
  // Check if mockResponses.json exists
  const mockResponsesPath = path.join(__dirname, 'src', 'data', 'mockResponses.json');
  try {
    if (fs.existsSync(mockResponsesPath)) {
      console.log(`${COLORS.green}✓ mockResponses.json found at: ${mockResponsesPath}${COLORS.reset}`);
      const stats = fs.statSync(mockResponsesPath);
      console.log(`  File size: ${(stats.size / 1024).toFixed(2)} KB`);
      console.log(`  Last modified: ${stats.mtime}`);
      
      // Check file content
      try {
        const content = fs.readFileSync(mockResponsesPath, 'utf8');
        const mockData = JSON.parse(content);
        const characterCount = Object.keys(mockData).filter(k => k !== 'fallback').length;
        console.log(`  Contains data for ${characterCount} characters`);
        console.log(`  Characters: ${Object.keys(mockData).filter(k => k !== 'fallback').join(', ')}`);
      } catch (err) {
        console.log(`${COLORS.red}✗ Error parsing mockResponses.json: ${err.message}${COLORS.reset}`);
      }
    } else {
      console.log(`${COLORS.red}✗ mockResponses.json NOT found at: ${mockResponsesPath}${COLORS.reset}`);
      console.log(`  This file should be generated by running generate_mock_responses.js`);
    }
  } catch (err) {
    console.log(`${COLORS.red}✗ Error checking mockResponses.json: ${err.message}${COLORS.reset}`);
  }
  
  // Check if mockResponseService.js exists
  const mockServicePath = path.join(__dirname, 'src', 'services', 'mockResponseService.js');
  if (fs.existsSync(mockServicePath)) {
    console.log(`\n${COLORS.green}✓ mockResponseService.js found at: ${mockServicePath}${COLORS.reset}`);
  } else {
    console.log(`\n${COLORS.red}✗ mockResponseService.js NOT found at: ${mockServicePath}${COLORS.reset}`);
    console.log(`  This file should contain the mock response generation logic`);
    return;
  }
  
  // Try to import the mockResponseService
  try {
    console.log(`\n${COLORS.cyan}Importing mockResponseService...${COLORS.reset}`);
    const mockServiceModule = await import('./src/services/mockResponseService.js');
    const { 
      generateMockResponse, 
      streamMockResponse, 
      areMockResponsesAvailable 
    } = mockServiceModule;
    
    // Check if the required functions are exported
    if (typeof generateMockResponse !== 'function') {
      console.log(`${COLORS.red}✗ generateMockResponse is not a function${COLORS.reset}`);
      return;
    }
    
    if (typeof streamMockResponse !== 'function') {
      console.log(`${COLORS.red}✗ streamMockResponse is not a function${COLORS.reset}`);
      return;
    }
    
    if (typeof areMockResponsesAvailable !== 'function') {
      console.log(`${COLORS.red}✗ areMockResponsesAvailable is not a function${COLORS.reset}`);
      return;
    }
    
    console.log(`${COLORS.green}✓ Successfully imported mockResponseService${COLORS.reset}`);
    
    // Check if mock responses are available
    const mockAvailable = areMockResponsesAvailable();
    if (mockAvailable) {
      console.log(`${COLORS.green}✓ Mock responses are available${COLORS.reset}`);
    } else {
      console.log(`${COLORS.red}✗ Mock responses are NOT available${COLORS.reset}`);
      return;
    }
    
    // Test characters and message scenarios
    const characters = [
      { name: "Jesus (Final)", persona: "Son of God, teacher, and savior" },
      { name: "Paul (Final)", persona: "Apostle to the Gentiles and writer of many New Testament epistles" },
      { name: "Moses (Final)", persona: "Prophet who led the Israelites out of Egypt" }
    ];
    
    const messageScenarios = [
      { name: "Greeting", messages: [{ role: "user", content: "Hello" }] },
      { name: "Faith Question", messages: [{ role: "user", content: "What is faith?" }] },
      { name: "Suffering Question", messages: [{ role: "user", content: "Why do good people suffer?" }] },
      { name: "Personal Question", messages: [{ role: "user", content: "Tell me about your life" }] },
      { name: "Complex Question", messages: [
        { role: "user", content: "Hello" },
        { role: "assistant", content: "Peace be with you. How may I assist you today?" },
        { role: "user", content: "How should I pray?" }
      ]}
    ];
    
    // Test generating responses
    console.log(`\n${COLORS.bright}${COLORS.blue}=== TESTING MOCK RESPONSE GENERATION ===\n${COLORS.reset}`);
    
    for (const character of characters) {
      console.log(`\n${COLORS.bright}Testing responses for ${character.name}:${COLORS.reset}`);
      
      for (const scenario of messageScenarios) {
        try {
          console.log(`\n  ${COLORS.cyan}Scenario: ${scenario.name}${COLORS.reset}`);
          console.log(`  Last user message: "${scenario.messages[scenario.messages.length - 1].content}"`);
          
          const response = generateMockResponse(character.name, character.persona, scenario.messages);
          
          console.log(`  ${COLORS.green}Response:${COLORS.reset} "${response.substring(0, 100)}${response.length > 100 ? '...' : ''}"`);
          console.log(`  Length: ${response.length} characters`);
        } catch (error) {
          console.log(`  ${COLORS.red}✗ Error generating response: ${error.message}${COLORS.reset}`);
          console.error(error);
        }
      }
    }
    
    // Test streaming responses
    console.log(`\n${COLORS.bright}${COLORS.blue}=== TESTING MOCK RESPONSE STREAMING ===\n${COLORS.reset}`);
    
    // Only test one character and scenario for streaming to keep output manageable
    const streamChar = characters[0];
    const streamScenario = messageScenarios[1];
    
    console.log(`${COLORS.bright}Testing streaming for ${streamChar.name}:${COLORS.reset}`);
    console.log(`Scenario: ${streamScenario.name}`);
    console.log(`Last user message: "${streamScenario.messages[streamScenario.messages.length - 1].content}"`);
    
    let streamedContent = '';
    let chunkCount = 0;
    
    try {
      console.log(`\n${COLORS.cyan}Streaming response (chunks will appear below):${COLORS.reset}`);
      console.log('---------------------------------------------------');
      
      await new Promise((resolve, reject) => {
        try {
          streamMockResponse(
            streamChar.name,
            streamChar.persona,
            streamScenario.messages,
            (chunk) => {
              chunkCount++;
              streamedContent += chunk;
              process.stdout.write(chunk);
            }
          ).then(resolve).catch(reject);
          
          // Set a timeout in case streaming never completes
          setTimeout(() => {
            reject(new Error('Streaming timed out after 10 seconds'));
          }, 10000);
        } catch (err) {
          reject(err);
        }
      });
      
      console.log('\n---------------------------------------------------');
      console.log(`${COLORS.green}✓ Streaming completed successfully${COLORS.reset}`);
      console.log(`  Received ${chunkCount} chunks`);
      console.log(`  Total length: ${streamedContent.length} characters`);
    } catch (error) {
      console.log('\n---------------------------------------------------');
      console.log(`${COLORS.red}✗ Error during streaming: ${error.message}${COLORS.reset}`);
      console.error(error);
    }
    
    // Test error handling by passing invalid parameters
    console.log(`\n${COLORS.bright}${COLORS.blue}=== TESTING ERROR HANDLING ===\n${COLORS.reset}`);
    
    try {
      console.log(`${COLORS.cyan}Testing with invalid character name:${COLORS.reset}`);
      const response = generateMockResponse("NonexistentCharacter", "This character doesn't exist", [{ role: "user", content: "Hello" }]);
      console.log(`${COLORS.green}Response:${COLORS.reset} "${response}"`);
    } catch (error) {
      console.log(`${COLORS.red}✗ Error with invalid character: ${error.message}${COLORS.reset}`);
    }
    
    try {
      console.log(`\n${COLORS.cyan}Testing with empty messages array:${COLORS.reset}`);
      const response = generateMockResponse("Jesus", "Son of God", []);
      console.log(`${COLORS.green}Response:${COLORS.reset} "${response}"`);
    } catch (error) {
      console.log(`${COLORS.red}✗ Error with empty messages: ${error.message}${COLORS.reset}`);
    }
    
    try {
      console.log(`\n${COLORS.cyan}Testing with null parameters:${COLORS.reset}`);
      const response = generateMockResponse(null, null, null);
      console.log(`${COLORS.green}Response:${COLORS.reset} "${response}"`);
    } catch (error) {
      console.log(`${COLORS.red}✗ Error with null parameters: ${error.message}${COLORS.reset}`);
    }
    
    // Final summary
    console.log(`\n${COLORS.bright}${COLORS.blue}=== DEBUG SUMMARY ===\n${COLORS.reset}`);
    console.log(`${COLORS.green}✓ Mock response system is properly installed${COLORS.reset}`);
    console.log(`${COLORS.green}✓ generateMockResponse function works correctly${COLORS.reset}`);
    console.log(`${COLORS.green}✓ streamMockResponse function works correctly${COLORS.reset}`);
    console.log(`${COLORS.green}✓ Error handling appears robust${COLORS.reset}`);
    
    console.log(`\n${COLORS.bright}${COLORS.blue}=== NEXT STEPS ===\n${COLORS.reset}`);
    console.log(`1. If you're still seeing "Sorry, something went wrong" in the app:`);
    console.log(`   - Check browser console for errors`);
    console.log(`   - Verify that openai.js is correctly importing mockResponseService.js`);
    console.log(`   - Ensure ChatContext.js properly handles errors from openai.js`);
    console.log(`   - Check that the build process included the mock response system`);
    
    console.log(`\n2. Try these commands to rebuild the app:`);
    console.log(`   npm run build`);
    console.log(`   npm run preview -- --port 5186`);
    
    console.log(`\n3. If problems persist, check for network issues or CORS errors in the browser console`);
    
  } catch (error) {
    console.log(`\n${COLORS.bgRed}${COLORS.bright} FATAL ERROR ${COLORS.reset}`);
    console.log(`${COLORS.red}Failed to import mockResponseService: ${error.message}${COLORS.reset}`);
    console.error(error);
  }
}

// Run the tests
runTests().catch(err => {
  console.error(`${COLORS.red}${COLORS.bright}Unhandled error in debug script:${COLORS.reset}`, err);
  process.exit(1);
});
