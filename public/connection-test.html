<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bible Character Chat - Connection Test</title>
  <style>
    :root {
      --primary-color: #1e3a8a;
      --secondary-color: #3b82f6;
      --accent-color: #f59e0b;
      --success-color: #10b981;
      --error-color: #ef4444;
      --warning-color: #f59e0b;
      --text-color: #1f2937;
      --bg-color: #f9fafb;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom, #1e3a8a, #2563eb, #3b82f6);
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 2rem;
    }
    
    .container {
      max-width: 800px;
      width: 100%;
      padding: 2rem;
      box-sizing: border-box;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 1.5rem;
      font-size: 2rem;
    }
    
    .card {
      background-color: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .test-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
    }
    
    .test-item {
      display: flex;
      align-items: center;
      padding: 1rem;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }
    
    .test-name {
      flex: 1;
      font-weight: 500;
    }
    
    .test-description {
      font-size: 0.875rem;
      opacity: 0.8;
      margin-top: 0.25rem;
    }
    
    .test-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .status-indicator {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #6b7280;
    }
    
    .status-pending {
      background-color: #6b7280;
    }
    
    .status-running {
      background-color: var(--warning-color);
      animation: pulse 1.5s infinite;
    }
    
    .status-success {
      background-color: var(--success-color);
    }
    
    .status-error {
      background-color: var(--error-color);
    }
    
    @keyframes pulse {
      0% {
        opacity: 0.6;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 0.6;
      }
    }
    
    .button {
      display: inline-block;
      background-color: var(--accent-color);
      color: var(--primary-color);
      font-weight: bold;
      padding: 0.75rem 1.5rem;
      border-radius: 9999px;
      text-decoration: none;
      margin-top: 1rem;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: background-color 0.2s;
    }
    
    .button:hover {
      background-color: #fbbf24;
    }
    
    .button-secondary {
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
    }
    
    .button-secondary:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }
    
    .test-details {
      margin-top: 0.5rem;
      font-family: monospace;
      font-size: 0.875rem;
      white-space: pre-wrap;
      background-color: rgba(0, 0, 0, 0.3);
      padding: 0.5rem;
      border-radius: 4px;
      max-height: 100px;
      overflow-y: auto;
      display: none;
    }
    
    .test-item.expanded .test-details {
      display: block;
    }
    
    .debug-panel {
      margin-top: 2rem;
      padding: 1rem;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      font-family: monospace;
      font-size: 0.875rem;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
      width: 100%;
    }
    
    .debug-entry {
      margin-bottom: 0.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 0.5rem;
    }
    
    .debug-timestamp {
      color: #a5f3fc;
      margin-right: 0.5rem;
    }
    
    .debug-level-info {
      color: #93c5fd;
    }
    
    .debug-level-success {
      color: #86efac;
    }
    
    .debug-level-error {
      color: #fca5a5;
    }
    
    .debug-level-warn {
      color: #fdba74;
    }
    
    .debug-content {
      margin-top: 0.25rem;
    }
    
    .summary-card {
      margin-top: 1.5rem;
      padding: 1rem;
      border-radius: 8px;
      font-weight: 500;
      text-align: center;
    }
    
    .summary-success {
      background-color: rgba(16, 185, 129, 0.2);
      border: 1px solid var(--success-color);
    }
    
    .summary-error {
      background-color: rgba(239, 68, 68, 0.2);
      border: 1px solid var(--error-color);
    }
    
    .summary-warning {
      background-color: rgba(245, 158, 11, 0.2);
      border: 1px solid var(--warning-color);
    }
    
    .troubleshooting {
      margin-top: 1.5rem;
    }
    
    .troubleshooting h3 {
      margin-bottom: 0.5rem;
    }
    
    .troubleshooting ul {
      padding-left: 1.5rem;
    }
    
    .troubleshooting li {
      margin-bottom: 0.5rem;
    }
    
    .hidden {
      display: none;
    }
    
    .footer {
      margin-top: 2rem;
      text-align: center;
      font-size: 0.875rem;
      opacity: 0.7;
    }
    
    .nav-links {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .nav-link {
      color: white;
      text-decoration: none;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    
    .nav-link:hover {
      opacity: 1;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Supabase Connection Test</h1>
    
    <div class="card">
      <p>This tool tests connectivity to the Supabase API and helps diagnose common issues.</p>
      
      <div class="test-grid" id="test-grid">
        <!-- Test items will be added here dynamically -->
      </div>
      
      <div class="button-group" style="text-align: center; margin-top: 1.5rem;">
        <button id="run-all-tests" class="button">Run All Tests</button>
        <button id="copy-results" class="button button-secondary">Copy Results</button>
      </div>
      
      <div id="summary" class="hidden">
        <!-- Summary will be added here dynamically -->
      </div>
      
      <div id="troubleshooting" class="troubleshooting hidden">
        <!-- Troubleshooting tips will be added here dynamically -->
      </div>
    </div>
    
    <div class="debug-panel" id="debug-panel">
      <div class="debug-entry">
        <span class="debug-timestamp">00:00:00</span>
        <span class="debug-level-info">INFO</span>
        <div class="debug-content">Connection test initialized. Click "Run All Tests" to begin.</div>
      </div>
    </div>
    
    <div class="nav-links">
      <a href="/login-fix.html" class="nav-link">Emergency Login</a>
      <a href="/admin-links.html" class="nav-link">Admin Links</a>
      <a href="/logout.html" class="nav-link">Logout</a>
      <a href="/" class="nav-link">Home</a>
    </div>
    
    <div class="footer">
      Bible Character Chat - Connection Diagnostic Tool
    </div>
  </div>
  
  <script>
    // -------------------------------------------------------------------------
    // Configuration
    // -------------------------------------------------------------------------
    
    const SUPABASE_URL = 'https://gzlpzsrpyytatfumkwgr.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd6bHB6c3JweXl0YXRmdW1rd2dyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MTU5MDQ5NzksImV4cCI6MjAzMTQ4MDk3OX0.RJpBzLDPkBgbmAQmrX_mLQFgSzDqLvVnUdJLLW5-Wqw';
    
    // -------------------------------------------------------------------------
    // Debug Utilities
    // -------------------------------------------------------------------------
    
    const debugPanel = document.getElementById('debug-panel');
    
    // Log a message to the debug panel
    function logDebug(message, level = 'info', data = null) {
      const timestamp = new Date().toTimeString().split(' ')[0];
      
      const entry = document.createElement('div');
      entry.className = 'debug-entry';
      
      const header = document.createElement('div');
      
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'debug-timestamp';
      timestampSpan.textContent = timestamp;
      
      const levelSpan = document.createElement('span');
      levelSpan.className = `debug-level-${level}`;
      levelSpan.textContent = level.toUpperCase();
      
      header.appendChild(timestampSpan);
      header.appendChild(levelSpan);
      
      const content = document.createElement('div');
      content.className = 'debug-content';
      
      if (typeof message === 'string') {
        content.textContent = message;
      } else {
        content.textContent = JSON.stringify(message, null, 2);
      }
      
      if (data) {
        const dataString = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
        content.textContent += '\n' + dataString;
      }
      
      entry.appendChild(header);
      entry.appendChild(content);
      
      debugPanel.appendChild(entry);
      debugPanel.scrollTop = debugPanel.scrollHeight;
      
      // Also log to console
      const consoleMethod = level === 'error' ? console.error : 
                           level === 'warn' ? console.warn : 
                           level === 'success' ? console.log : console.info;
      
      consoleMethod(`[${timestamp}] [${level.toUpperCase()}] ${message}`, data || '');
    }
    
    // -------------------------------------------------------------------------
    // Test Definitions
    // -------------------------------------------------------------------------
    
    const tests = [
      {
        id: 'internet-connectivity',
        name: 'Internet Connectivity',
        description: 'Checks if your browser can connect to the internet',
        async run() {
          try {
            const startTime = performance.now();
            const response = await fetch('https://www.google.com/favicon.ico', {
              method: 'HEAD',
              mode: 'no-cors',
              cache: 'no-cache',
            });
            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);
            
            return {
              success: true,
              message: `Connected to Google in ${latency}ms`,
              details: {
                latency,
                timestamp: new Date().toISOString()
              }
            };
          } catch (error) {
            return {
              success: false,
              message: 'Failed to connect to the internet',
              details: {
                error: error.message,
                stack: error.stack
              }
            };
          }
        }
      },
      {
        id: 'supabase-ping',
        name: 'Supabase API Ping',
        description: 'Checks if the Supabase API endpoint is reachable',
        async run() {
          try {
            const startTime = performance.now();
            const response = await fetch(`${SUPABASE_URL}/ping`, {
              method: 'GET',
              cache: 'no-cache',
            });
            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);
            
            if (!response.ok) {
              return {
                success: false,
                message: `Supabase ping failed with status ${response.status}`,
                details: {
                  status: response.status,
                  statusText: response.statusText,
                  latency
                }
              };
            }
            
            const data = await response.text();
            
            return {
              success: true,
              message: `Supabase ping successful (${latency}ms)`,
              details: {
                latency,
                response: data,
                timestamp: new Date().toISOString()
              }
            };
          } catch (error) {
            return {
              success: false,
              message: 'Failed to ping Supabase API',
              details: {
                error: error.message,
                stack: error.stack
              }
            };
          }
        }
      },
      {
        id: 'cors-test',
        name: 'CORS Configuration',
        description: 'Checks if CORS is properly configured for the Supabase API',
        async run() {
          try {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/`, {
              method: 'OPTIONS',
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Content-Type': 'application/json'
              }
            });
            
            const corsHeaders = {
              'Access-Control-Allow-Origin': response.headers.get('Access-Control-Allow-Origin'),
              'Access-Control-Allow-Methods': response.headers.get('Access-Control-Allow-Methods'),
              'Access-Control-Allow-Headers': response.headers.get('Access-Control-Allow-Headers')
            };
            
            const hasValidCors = corsHeaders['Access-Control-Allow-Origin'] !== null;
            
            return {
              success: hasValidCors,
              message: hasValidCors ? 'CORS is properly configured' : 'CORS headers are missing',
              details: {
                corsHeaders,
                status: response.status,
                statusText: response.statusText
              }
            };
          } catch (error) {
            return {
              success: false,
              message: 'CORS test failed',
              details: {
                error: error.message,
                stack: error.stack
              }
            };
          }
        }
      },
      {
        id: 'auth-endpoint',
        name: 'Authentication Endpoint',
        description: 'Tests connectivity to the Supabase auth API',
        async run() {
          try {
            const response = await fetch(`${SUPABASE_URL}/auth/v1/token?grant_type=password`, {
              method: 'POST',
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                email: 'test@example.com',
                password: 'invalid_password_for_testing'
              })
            });
            
            // We expect this to fail with a 400 Bad Request (invalid credentials)
            // but the important thing is that we got a response from the auth endpoint
            const isReachable = response.status === 400 || response.status === 200;
            
            let responseData;
            try {
              responseData = await response.json();
            } catch (e) {
              responseData = { error: 'Failed to parse response as JSON' };
            }
            
            return {
              success: isReachable,
              message: isReachable ? 
                'Authentication endpoint is reachable' : 
                `Authentication endpoint returned unexpected status: ${response.status}`,
              details: {
                status: response.status,
                statusText: response.statusText,
                response: responseData
              }
            };
          } catch (error) {
            return {
              success: false,
              message: 'Failed to connect to authentication endpoint',
              details: {
                error: error.message,
                stack: error.stack
              }
            };
          }
        }
      },
      {
        id: 'database-query',
        name: 'Database Query',
        description: 'Tests if the database is accessible and queryable',
        async run() {
          try {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/characters?select=count`, {
              method: 'GET',
              headers: {
                'apikey': SUPABASE_ANON_KEY,
                'Content-Type': 'application/json'
              }
            });
            
            let responseData;
            try {
              responseData = await response.json();
            } catch (e) {
              responseData = { error: 'Failed to parse response as JSON' };
            }
            
            const isQueryable = response.ok;
            
            return {
              success: isQueryable,
              message: isQueryable ? 
                'Database is accessible and queryable' : 
                `Database query failed with status: ${response.status}`,
              details: {
                status: response.status,
                statusText: response.statusText,
                response: responseData
              }
            };
          } catch (error) {
            return {
              success: false,
              message: 'Failed to query database',
              details: {
                error: error.message,
                stack: error.stack
              }
            };
          }
        }
      },
      {
        id: 'network-latency',
        name: 'Network Latency',
        description: 'Measures the round-trip time to the Supabase API',
        async run() {
          try {
            const samples = [];
            const numSamples = 3;
            
            for (let i = 0; i < numSamples; i++) {
              const startTime = performance.now();
              await fetch(`${SUPABASE_URL}/ping`, {
                method: 'GET',
                cache: 'no-cache',
              });
              const endTime = performance.now();
              samples.push(Math.round(endTime - startTime));
              
              // Small delay between samples
              await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            const avgLatency = Math.round(samples.reduce((a, b) => a + b, 0) / samples.length);
            const minLatency = Math.min(...samples);
            const maxLatency = Math.max(...samples);
            
            const isGoodLatency = avgLatency < 300;
            const isAcceptableLatency = avgLatency < 1000;
            
            let message;
            if (isGoodLatency) {
              message = `Good latency: ${avgLatency}ms average`;
            } else if (isAcceptableLatency) {
              message = `Acceptable latency: ${avgLatency}ms average`;
            } else {
              message = `High latency: ${avgLatency}ms average`;
            }
            
            return {
              success: isAcceptableLatency,
              message,
              details: {
                average: avgLatency,
                min: minLatency,
                max: maxLatency,
                samples
              }
            };
          } catch (error) {
            return {
              success: false,
              message: 'Failed to measure network latency',
              details: {
                error: error.message,
                stack: error.stack
              }
            };
          }
        }
      },
      {
        id: 'browser-info',
        name: 'Browser Information',
        description: 'Collects information about your browser environment',
        async run() {
          try {
            const browserInfo = {
              userAgent: navigator.userAgent,
              language: navigator.language,
              cookiesEnabled: navigator.cookieEnabled,
              doNotTrack: navigator.doNotTrack,
              onLine: navigator.onLine,
              platform: navigator.platform,
              vendor: navigator.vendor,
              screenWidth: window.screen.width,
              screenHeight: window.screen.height,
              timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
              localStorage: typeof localStorage !== 'undefined',
              sessionStorage: typeof sessionStorage !== 'undefined',
              indexedDB: typeof indexedDB !== 'undefined',
              serviceWorker: 'serviceWorker' in navigator,
              webSockets: 'WebSocket' in window,
              webRTC: 'RTCPeerConnection' in window,
              webGL: (() => {
                try {
                  const canvas = document.createElement('canvas');
                  return !!(window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                } catch (e) {
                  return false;
                }
              })()
            };
            
            return {
              success: true,
              message: `Browser information collected`,
              details: browserInfo
            };
          } catch (error) {
            return {
              success: false,
              message: 'Failed to collect browser information',
              details: {
                error: error.message,
                stack: error.stack
              }
            };
          }
        }
      }
    ];
    
    // -------------------------------------------------------------------------
    // Test Runner
    // -------------------------------------------------------------------------
    
    // Create test items in the UI
    function createTestItems() {
      const testGrid = document.getElementById('test-grid');
      testGrid.innerHTML = '';
      
      tests.forEach(test => {
        const testItem = document.createElement('div');
        testItem.className = 'test-item';
        testItem.dataset.testId = test.id;
        
        const testInfo = document.createElement('div');
        testInfo.className = 'test-info';
        
        const testName = document.createElement('div');
        testName.className = 'test-name';
        testName.textContent = test.name;
        
        const testDescription = document.createElement('div');
        testDescription.className = 'test-description';
        testDescription.textContent = test.description;
        
        testInfo.appendChild(testName);
        testInfo.appendChild(testDescription);
        
        const testStatus = document.createElement('div');
        testStatus.className = 'test-status';
        
        const statusIndicator = document.createElement('div');
        statusIndicator.className = 'status-indicator status-pending';
        
        const statusText = document.createElement('span');
        statusText.textContent = 'Pending';
        
        testStatus.appendChild(statusIndicator);
        testStatus.appendChild(statusText);
        
        const testDetails = document.createElement('div');
        testDetails.className = 'test-details';
        testDetails.textContent = 'Test not yet run';
        
        testItem.appendChild(testInfo);
        testItem.appendChild(testStatus);
        testItem.appendChild(testDetails);
        
        // Toggle details on click
        testItem.addEventListener('click', () => {
          testItem.classList.toggle('expanded');
        });
        
        testGrid.appendChild(testItem);
      });
    }
    
    // Run a single test
    async function runTest(testId) {
      const test = tests.find(t => t.id === testId);
      if (!test) return;
      
      const testItem = document.querySelector(`.test-item[data-test-id="${testId}"]`);
      const statusIndicator = testItem.querySelector('.status-indicator');
      const statusText = testItem.querySelector('.test-status span');
      const testDetails = testItem.querySelector('.test-details');
      
      // Update UI to show test is running
      statusIndicator.className = 'status-indicator status-running';
      statusText.textContent = 'Running...';
      
      logDebug(`Running test: ${test.name}`, 'info');
      
      try {
        // Run the test
        const result = await test.run();
        
        // Update UI with test results
        if (result.success) {
          statusIndicator.className = 'status-indicator status-success';
          statusText.textContent = 'Success';
          logDebug(`Test "${test.name}" succeeded: ${result.message}`, 'success', result.details);
        } else {
          statusIndicator.className = 'status-indicator status-error';
          statusText.textContent = 'Failed';
          logDebug(`Test "${test.name}" failed: ${result.message}`, 'error', result.details);
        }
        
        testDetails.textContent = result.message;
        if (result.details) {
          testDetails.textContent += '\n\n' + JSON.stringify(result.details, null, 2);
        }
        
        return result;
      } catch (error) {
        // Handle unexpected errors
        statusIndicator.className = 'status-indicator status-error';
        statusText.textContent = 'Error';
        testDetails.textContent = `Unexpected error: ${error.message}`;
        
        logDebug(`Test "${test.name}" threw an error`, 'error', {
          error: error.message,
          stack: error.stack
        });
        
        return {
          success: false,
          message: `Unexpected error: ${error.message}`,
          details: {
            error: error.message,
            stack: error.stack
          }
        };
      }
    }
    
    // Run all tests
    async function runAllTests() {
      const runAllButton = document.getElementById('run-all-tests');
      runAllButton.disabled = true;
      runAllButton.textContent = 'Running Tests...';
      
      logDebug('Starting all tests', 'info');
      
      const results = {};
      
      for (const test of tests) {
        results[test.id] = await runTest(test.id);
      }
      
      // Generate summary
      const summary = document.getElementById('summary');
      const troubleshooting = document.getElementById('troubleshooting');
      
      const successCount = Object.values(results).filter(r => r.success).length;
      const totalCount = tests.length;
      
      let summaryClass = '';
      let summaryText = '';
      
      if (successCount === totalCount) {
        summaryClass = 'summary-success';
        summaryText = '✅ All tests passed! Your connection to Supabase is working correctly.';
      } else if (successCount >= totalCount / 2) {
        summaryClass = 'summary-warning';
        summaryText = `⚠️ ${successCount} of ${totalCount} tests passed. There might be some connectivity issues.`;
      } else {
        summaryClass = 'summary-error';
        summaryText = `❌ Only ${successCount} of ${totalCount} tests passed. There are significant connectivity issues.`;
      }
      
      summary.className = `summary-card ${summaryClass}`;
      summary.textContent = summaryText;
      summary.classList.remove('hidden');
      
      // Generate troubleshooting tips
      generateTroubleshooting(results);
      
      runAllButton.disabled = false;
      runAllButton.textContent = 'Run All Tests';
      
      logDebug('All tests completed', 'info', {
        successCount,
        totalCount,
        results
      });
    }
    
    // Generate troubleshooting tips based on test results
    function generateTroubleshooting(results) {
      const troubleshooting = document.getElementById('troubleshooting');
      troubleshooting.innerHTML = '';
      
      const tips = [];
      
      // Internet connectivity issues
      if (!results['internet-connectivity'].success) {
        tips.push('Check your internet connection. You appear to be offline or have limited connectivity.');
        tips.push('Try connecting to a different network if available.');
        tips.push('Disable any VPN or proxy services that might be interfering with connections.');
      }
      
      // Supabase API issues
      if (!results['supabase-ping'].success) {
        tips.push('The Supabase API endpoint might be down or unreachable.');
        tips.push('Verify that the Supabase URL is correct.');
        tips.push('Check if your network is blocking requests to the Supabase domain.');
      }
      
      // CORS issues
      if (!results['cors-test'].success) {
        tips.push('There appears to be a CORS configuration issue with the Supabase API.');
        tips.push('Ensure that your current domain is allowed in the Supabase project settings.');
        tips.push('Try accessing the app from a different browser or device.');
      }
      
      // Auth endpoint issues
      if (!results['auth-endpoint'].success) {
        tips.push('The authentication endpoint is not responding correctly.');
        tips.push('Check if the Supabase anon key is correct and has the necessary permissions.');
        tips.push('Verify that the auth services in your Supabase project are enabled.');
      }
      
      // Database issues
      if (!results['database-query'].success) {
        tips.push('The database is not accessible or queryable.');
        tips.push('Verify that your database is online and the schema is correctly set up.');
        tips.push('Check if the anon key has the necessary permissions to access the database.');
      }
      
      // Latency issues
      if (!results['network-latency'].success) {
        tips.push('High network latency detected. This might cause timeouts or slow responses.');
        tips.push('Try connecting to a faster or more stable network.');
        tips.push('Check if other devices on your network are consuming bandwidth.');
      }
      
      // Add tips to the troubleshooting section
      if (tips.length > 0) {
        const heading = document.createElement('h3');
        heading.textContent = 'Troubleshooting Tips';
        
        const list = document.createElement('ul');
        
        tips.forEach(tip => {
          const item = document.createElement('li');
          item.textContent = tip;
          list.appendChild(item);
        });
        
        troubleshooting.appendChild(heading);
        troubleshooting.appendChild(list);
        troubleshooting.classList.remove('hidden');
      }
    }
    
    // Copy test results to clipboard
    function copyResults() {
      const testItems = document.querySelectorAll('.test-item');
      let resultsText = 'Bible Character Chat - Supabase Connection Test Results\n';
      resultsText += `Timestamp: ${new Date().toISOString()}\n\n`;
      
      testItems.forEach(item => {
        const testName = item.querySelector('.test-name').textContent;
        const statusText = item.querySelector('.test-status span').textContent;
        const details = item.querySelector('.test-details').textContent;
        
        resultsText += `Test: ${testName}\n`;
        resultsText += `Status: ${statusText}\n`;
        resultsText += `Details: ${details}\n\n`;
      });
      
      // Add browser information
      resultsText += `Browser: ${navigator.userAgent}\n`;
      resultsText += `Online: ${navigator.onLine}\n`;
      resultsText += `Platform: ${navigator.platform}\n`;
      
      // Copy to clipboard
      navigator.clipboard.writeText(resultsText)
        .then(() => {
          alert('Test results copied to clipboard!');
          logDebug('Test results copied to clipboard', 'success');
        })
        .catch(err => {
          alert('Failed to copy results: ' + err.message);
          logDebug('Failed to copy test results', 'error', err);
        });
    }
    
    // -------------------------------------------------------------------------
    // Event Listeners
    // -------------------------------------------------------------------------
    
    document.getElementById('run-all-tests').addEventListener('click', runAllTests);
    document.getElementById('copy-results').addEventListener('click', copyResults);
    
    // -------------------------------------------------------------------------
    // Initialization
    // -------------------------------------------------------------------------
    
    document.addEventListener('DOMContentLoaded', () => {
      createTestItems();
      logDebug('Connection test page initialized', 'info', {
        supabaseUrl: SUPABASE_URL,
        timestamp: new Date().toISOString(),
        online: navigator.onLine,
        userAgent: navigator.userAgent
      });
    });
  </script>
</body>
</html>
